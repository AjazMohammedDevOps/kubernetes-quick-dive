{
    "docs": [
        {
            "location": "/", 
            "text": "Kubernetes Quick Dive\n\n\nWelcome to Kubernetes Quick Dive by School of Devops\n\n\nThis is a Lab Guide which goes along with the Docker and Kubernetes course by School of Devops.\n\n\nFor information about the devops trainign courses visit \nschoolofdevops.com\n.\n\n\nTeam\n\n\n\n\nGourav Shah\n\n\nVijayboopathy", 
            "title": "Home"
        }, 
        {
            "location": "/#kubernetes-quick-dive", 
            "text": "Welcome to Kubernetes Quick Dive by School of Devops  This is a Lab Guide which goes along with the Docker and Kubernetes course by School of Devops.  For information about the devops trainign courses visit  schoolofdevops.com .", 
            "title": "Kubernetes Quick Dive"
        }, 
        {
            "location": "/#team", 
            "text": "Gourav Shah  Vijayboopathy", 
            "title": "Team"
        }, 
        {
            "location": "/minikube/", 
            "text": "Single node k8s cluster with Minikube\n\n\nMinikube offers one of the easiest zero to dev experience\nto setup a single node kubernetes cluster. Its also the ideal way\nto create a local dev environment to test kubernetes code on.\n\n\nThis document explains how to setup and work with single node kubernetes cluster with minikube.\n\n\nInstall Minikube\n\n\nInstructions to install minikube may vary based on the operating system and choice of the hypervisor.\n\nThis is the official document\n which explains how to install minikube.\n\n\nStart all in one single node cluster with minikube\n\n\nminikube status\n\n\n\n\n[output]\n\n\nminikube:\ncluster:\nkubectl:\n\n\n\n\nminikube start\n\n\n\n\n[output]\n\n\nStarting local Kubernetes v1.8.0 cluster...\nStarting VM...\nGetting VM IP address...\nMoving files into cluster...\nSetting up certs...\nConnecting to cluster...\nSetting up kubeconfig...\nStarting cluster components...\nKubectl is now configured to use the cluster.\nLoading cached images from config file.\n\n\n\n\nminikube status\n\n\n\n\n\n[output]\n\n\nminikube: Running\ncluster: Running\nkubectl: Correctly Configured: pointing to minikube-vm at 192.168.99.100\n\n\n\n\nLaunch a kubernetes dashboard\n\n\nminikube dashboard\n\n\n\n\nSetting up docker environment\n\n\nminikube docker-env\nexport DOCKER_TLS_VERIFY=\n1\n\nexport DOCKER_HOST=\ntcp://192.168.99.100:2376\n\nexport DOCKER_CERT_PATH=\n/Users/gouravshah/.minikube/certs\n\nexport DOCKER_API_VERSION=\n1.23\n\n# Run this command to configure your shell:\n# eval $(minikube docker-env)\n\n\n\n\nRun the command given above,\ne.g.\n\n\neval $(minikube docker-env)\n\n\n\n\nNow your docker client should be able to connect with the minikube cluster\n\n\ndocker ps\n\n\n\n\nAdditional Commands\n\n\nminikube ip\nminikube get-k8s-versions\nminikube logs", 
            "title": "Using minikube to setup single node environment"
        }, 
        {
            "location": "/minikube/#single-node-k8s-cluster-with-minikube", 
            "text": "Minikube offers one of the easiest zero to dev experience\nto setup a single node kubernetes cluster. Its also the ideal way\nto create a local dev environment to test kubernetes code on.  This document explains how to setup and work with single node kubernetes cluster with minikube.", 
            "title": "Single node k8s cluster with Minikube"
        }, 
        {
            "location": "/minikube/#install-minikube", 
            "text": "Instructions to install minikube may vary based on the operating system and choice of the hypervisor. This is the official document  which explains how to install minikube.", 
            "title": "Install Minikube"
        }, 
        {
            "location": "/minikube/#start-all-in-one-single-node-cluster-with-minikube", 
            "text": "minikube status  [output]  minikube:\ncluster:\nkubectl:  minikube start  [output]  Starting local Kubernetes v1.8.0 cluster...\nStarting VM...\nGetting VM IP address...\nMoving files into cluster...\nSetting up certs...\nConnecting to cluster...\nSetting up kubeconfig...\nStarting cluster components...\nKubectl is now configured to use the cluster.\nLoading cached images from config file.  minikube status  [output]  minikube: Running\ncluster: Running\nkubectl: Correctly Configured: pointing to minikube-vm at 192.168.99.100", 
            "title": "Start all in one single node cluster with minikube"
        }, 
        {
            "location": "/minikube/#launch-a-kubernetes-dashboard", 
            "text": "minikube dashboard", 
            "title": "Launch a kubernetes dashboard"
        }, 
        {
            "location": "/minikube/#setting-up-docker-environment", 
            "text": "minikube docker-env\nexport DOCKER_TLS_VERIFY= 1 \nexport DOCKER_HOST= tcp://192.168.99.100:2376 \nexport DOCKER_CERT_PATH= /Users/gouravshah/.minikube/certs \nexport DOCKER_API_VERSION= 1.23 \n# Run this command to configure your shell:\n# eval $(minikube docker-env)  Run the command given above,\ne.g.  eval $(minikube docker-env)  Now your docker client should be able to connect with the minikube cluster  docker ps", 
            "title": "Setting up docker environment"
        }, 
        {
            "location": "/minikube/#additional-commands", 
            "text": "minikube ip\nminikube get-k8s-versions\nminikube logs", 
            "title": "Additional Commands"
        }, 
        {
            "location": "/kube_visualizer/", 
            "text": "Kubernetes Visualizer\n\n\nIn this chapter we will see how to set up kubernetes visualizer that will show us the changes in our cluster in real time.\n\n\nSet up\n\n\nIf using play-with-k8s, install git\n\n\nyum install -y git\n\n\n\n\nClone the repository\n\n\n\ngit clone  https://github.com/schoolofdevops/kube-ops-view\n\n\n\n\n\nDeploy the visualizer on kubernetes\n\n\ncd  kube-ops-view\nkubectl apply -f deploy/\n\n[ouput]\nserviceaccount \nkube-ops-view\n created\nclusterrole \nkube-ops-view\n created\nclusterrolebinding \nkube-ops-view\n created\ndeployment \nkube-ops-view\n created\ningress \nkube-ops-view\n created\ndeployment \nkube-ops-view-redis\n created\nservice \nkube-ops-view-redis\n created\nservice \nkube-ops-view\n created\n\n\n\n\nGet the nodeport for the service.\n\n\nkubectl get svc\n\n[output]\nNAME                  TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE\nkube-ops-view         NodePort    10.107.204.74   \nnone\n        80:**30073**/TCP   1m\nkube-ops-view-redis   ClusterIP   10.104.50.176   \nnone\n        6379/TCP       1m\nkubernetes            ClusterIP   10.96.0.1       \nnone\n        443/TCP        8m\n\n\n\n\nIn my case, port \n30073\n is the nodeport.\n\n\nVisit the port from the browser.\n\n\nhttp://\nNODE_IP:NODE_PORT", 
            "title": "Visualising Kuberentes Cluster"
        }, 
        {
            "location": "/kube_visualizer/#kubernetes-visualizer", 
            "text": "In this chapter we will see how to set up kubernetes visualizer that will show us the changes in our cluster in real time.", 
            "title": "Kubernetes Visualizer"
        }, 
        {
            "location": "/kube_visualizer/#set-up", 
            "text": "If using play-with-k8s, install git  yum install -y git  Clone the repository  \ngit clone  https://github.com/schoolofdevops/kube-ops-view  Deploy the visualizer on kubernetes  cd  kube-ops-view\nkubectl apply -f deploy/\n\n[ouput]\nserviceaccount  kube-ops-view  created\nclusterrole  kube-ops-view  created\nclusterrolebinding  kube-ops-view  created\ndeployment  kube-ops-view  created\ningress  kube-ops-view  created\ndeployment  kube-ops-view-redis  created\nservice  kube-ops-view-redis  created\nservice  kube-ops-view  created  Get the nodeport for the service.  kubectl get svc\n\n[output]\nNAME                  TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE\nkube-ops-view         NodePort    10.107.204.74    none         80:**30073**/TCP   1m\nkube-ops-view-redis   ClusterIP   10.104.50.176    none         6379/TCP       1m\nkubernetes            ClusterIP   10.96.0.1        none         443/TCP        8m  In my case, port  30073  is the nodeport.  Visit the port from the browser.  http:// NODE_IP:NODE_PORT", 
            "title": "Set up"
        }, 
        {
            "location": "/6_kubernetes_deployment/", 
            "text": "Deploying Applications\n\n\nA Deployment is a higher level abstraction which sits on top of replica sets and allows you to manage the way applications are deployed, rolled back at a controlled rate.\n\n\nDeployment has mainly two responsibilities,\n\n\n\n\nProvide Fault Tolerance: Maintain the number of replicas for a type of service/app. Schedule/delete pods to meet the desired count.\n\n\nUpdate Strategy: Define a release strategy and update the pods accordingly.\n\n\n\n\nLets write the deployment specs  with replication set to  8.\n\n\nFile: /code/vote-deploy.yaml\n\n\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: vote\nspec:\n  replicas: 3\n  template:\n    metadata:\n      labels:\n        app: vote\n        role: ui\n    spec:\n      containers:\n      - image: schoolofdevops/vote\n        name: vote\n        ports:\n        - containerPort: 80\n          protocol: TCP\n\n\n\n\nLets  create the Deployment\n\n\nkubectl apply -f vote-deploy.yaml\n\n\n\n\nLets validate the deployments,\n\n\nkubectl get deployment\nkubectl get rs\nkubectl get deploy,pods,rs\nkubectl rollout status deployment/vote\nkubectl get pods --show-labels\n\n\n\n\nSample Output\n\n\nkubectl get deployments\nNAME       DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE\nvote   3         3         3            1           3m\n\n\n\n\nScaling a deployment\n\n\nTo scale a deployment in Kubernetes:\n\n\nkubectl scale deployment/vote --replicas=5\n\n\n\n\nSample output:\n\n\nkubectl scale deployment/vote --replicas=5\ndeployment \nvote\n scaled", 
            "title": "Creating Deployments"
        }, 
        {
            "location": "/6_kubernetes_deployment/#deploying-applications", 
            "text": "A Deployment is a higher level abstraction which sits on top of replica sets and allows you to manage the way applications are deployed, rolled back at a controlled rate.  Deployment has mainly two responsibilities,   Provide Fault Tolerance: Maintain the number of replicas for a type of service/app. Schedule/delete pods to meet the desired count.  Update Strategy: Define a release strategy and update the pods accordingly.   Lets write the deployment specs  with replication set to  8.  File: /code/vote-deploy.yaml  apiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: vote\nspec:\n  replicas: 3\n  template:\n    metadata:\n      labels:\n        app: vote\n        role: ui\n    spec:\n      containers:\n      - image: schoolofdevops/vote\n        name: vote\n        ports:\n        - containerPort: 80\n          protocol: TCP  Lets  create the Deployment  kubectl apply -f vote-deploy.yaml  Lets validate the deployments,  kubectl get deployment\nkubectl get rs\nkubectl get deploy,pods,rs\nkubectl rollout status deployment/vote\nkubectl get pods --show-labels  Sample Output  kubectl get deployments\nNAME       DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE\nvote   3         3         3            1           3m", 
            "title": "Deploying Applications"
        }, 
        {
            "location": "/6_kubernetes_deployment/#scaling-a-deployment", 
            "text": "To scale a deployment in Kubernetes:  kubectl scale deployment/vote --replicas=5  Sample output:  kubectl scale deployment/vote --replicas=5\ndeployment  vote  scaled", 
            "title": "Scaling a deployment"
        }, 
        {
            "location": "/7_exposing_app_with_service/", 
            "text": "Exposing Application with  a Service\n\n\nTypes of Services:   \n\n\n\n\nClusterIP\n\n\nNodePort\n\n\nLoadBalancer\n\n\nExternalName\n\n\n\n\n\n\nkubectl get pods\nkubectl get svc\n\n\n\n\nSample Output:\n\n\nNAME                READY     STATUS    RESTARTS   AGE\nvoting-appp-1j52x   1/1       Running   0          12m\nvoting-appp-pr2xz   1/1       Running   0          9m\nvoting-appp-qpxbm   1/1       Running   0          15m\n\n\n\n\nPublishing a service with NodePort\n\n\nFilename: vote-svc.yaml\n\n\n---\napiVersion: v1\nkind: Service\nmetadata:\n  labels:\n    role: svc\n    tier: front\n  name: vote\nspec:\n  selector:\n    app: vote\n  ports:\n  - port: 80\n    protocol: TCP\n    targetPort: 80\n  type: NodePort\n\n\n\n\nSave the file.\n\n\nNow to create a service:\n\n\nkubectl apply -f vote-svc.yaml\nkubectl get svc\n\n\n\n\nNow to check which port the pod is connected\n\n\nkubectl describe service vote\n\n\n\n\nCheck for the Nodeport here\n\n\nSample Output\n\n\nName:                     vote\nNamespace:                instavote\nLabels:                   role=svc\n                          tier=front\nAnnotations:              kubectl.kubernetes.io/last-applied-configuration={\napiVersion\n:\nv1\n,\nkind\n:\nService\n,\nmetadata\n:{\nannotations\n:{},\nlabels\n:{\nrole\n:\nsvc\n,\ntier\n:\nfront\n},\nname\n:\nvote\n,\nnamespace\n:\ninstavote\n},\nspec\n:{...\nSelector:                 app=vote\nType:                     NodePort\nIP:                       10.108.108.157\nPort:                     \nunset\n  80/TCP\nTargetPort:               80/TCP\nNodePort:                 \nunset\n  31429/TCP\nEndpoints:                10.38.0.4:80,10.38.0.5:80,10.38.0.6:80 + 2 more...\nSession Affinity:         None\nExternal Traffic Policy:  Cluster\nEvents:                   \nnone\n\n\n\n\n\nGo to browser and check hostip:NodePort\n\n\nHere the node port is 31429.\n\n\nSample output will be:", 
            "title": "Service Endpoints"
        }, 
        {
            "location": "/7_exposing_app_with_service/#exposing-application-with-a-service", 
            "text": "Types of Services:      ClusterIP  NodePort  LoadBalancer  ExternalName    kubectl get pods\nkubectl get svc  Sample Output:  NAME                READY     STATUS    RESTARTS   AGE\nvoting-appp-1j52x   1/1       Running   0          12m\nvoting-appp-pr2xz   1/1       Running   0          9m\nvoting-appp-qpxbm   1/1       Running   0          15m", 
            "title": "Exposing Application with  a Service"
        }, 
        {
            "location": "/7_exposing_app_with_service/#publishing-a-service-with-nodeport", 
            "text": "Filename: vote-svc.yaml  ---\napiVersion: v1\nkind: Service\nmetadata:\n  labels:\n    role: svc\n    tier: front\n  name: vote\nspec:\n  selector:\n    app: vote\n  ports:\n  - port: 80\n    protocol: TCP\n    targetPort: 80\n  type: NodePort  Save the file.  Now to create a service:  kubectl apply -f vote-svc.yaml\nkubectl get svc  Now to check which port the pod is connected  kubectl describe service vote  Check for the Nodeport here  Sample Output  Name:                     vote\nNamespace:                instavote\nLabels:                   role=svc\n                          tier=front\nAnnotations:              kubectl.kubernetes.io/last-applied-configuration={ apiVersion : v1 , kind : Service , metadata :{ annotations :{}, labels :{ role : svc , tier : front }, name : vote , namespace : instavote }, spec :{...\nSelector:                 app=vote\nType:                     NodePort\nIP:                       10.108.108.157\nPort:                      unset   80/TCP\nTargetPort:               80/TCP\nNodePort:                  unset   31429/TCP\nEndpoints:                10.38.0.4:80,10.38.0.5:80,10.38.0.6:80 + 2 more...\nSession Affinity:         None\nExternal Traffic Policy:  Cluster\nEvents:                    none   Go to browser and check hostip:NodePort  Here the node port is 31429.  Sample output will be:", 
            "title": "Publishing a service with NodePort"
        }, 
        {
            "location": "/8_rollouts_and_rollbacks/", 
            "text": "Rolling updates with deployments\n\n\nLets create the update/deployment strategy as follows\n\n\nrevisionHistoryLimit: 4\nstrategy:\n  type: RollingUpdate\n  rollingUpdate:\n    maxUnavailable: 1\n    maxSurge: 2\nminReadySeconds: 20\n\n\n\n\n\nHere,\n\n\nstrategy.type\n : rolling updates which deploys pods in batches. Batch size is determined by following factors\n  * maxUnavailable\n  * maxSurge\n\n\nminReadySeconds\n : Time taken by the application to come up and be operational.\n\n\nThe above specs need to be added to the deployment configs as follows,\n\n\nFile: vote-deploy.yaml\n\n\napiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: vote\nspec:\n  replicas: 8\n  revisionHistoryLimit: 4\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 1\n      maxSurge: 2\n  minReadySeconds: 20\n  template:\n    metadata:\n      labels:\n        app: vote\n        role: ui\n    spec:\n      containers:\n      - image: schoolofdevops/vote\n        name: vote\n        ports:\n        - containerPort: 80\n          protocol: TCP\n\n\n\n\n\n\nUpdate the version of the image in vote_deploy.yaml\n\n\nFile: vote-deploy.yaml\n\n\n...\n    app: vote\n    spec:\n      containers:\n      - image: schoolofdevops/vote:movies\n\n\n\n\n\nApply Changes and monitor the rollout\n\n\nkubectl apply -f vote-deploy.yaml\nkubectl rollout status deployment/vote\n\n\n\n\nRolling Back a Failed Update\n\n\nLets update the image to a tag which is non existent. We intentionally introduce this intentional error to fail fail the deployment.\n\n\nFile: vote-deploy.yaml\n\n\n...\n    app: vote\n    spec:\n      containers:\n      - image: schoolofdevops/vote:movi\n\n\n\n\n\nDo a new rollout and monitor\n\n\nkubectl apply -f vote-deploy.yaml\nkubectl rollout status deployment/vote\n\n\n\n\nAlso watch the pod status which might look like\n\n\nvote-3040199436-sdq17   1/1       Running            0          9m\nvote-4086029260-0vjjb   0/1       ErrImagePull       0          16s\nvote-4086029260-zvgmd   0/1       ImagePullBackOff   0          15s\nvote-rc-fsdsd               1/1       Running            0          27m\nvote-rc-mcxs5               1/1       Running            0\n\n\n\n\nTo get the revision history and details  \n\n\nkubectl rollout history deployment/vote\nkubectl rollout history deployment/vote --revision=x\n[replace x with the latest revision]\n\n\n\n\n[Sample Output]\n\n\nroot@kube-01:~# kubectl rollout history deployment/vote\ndeployments \nvote\n\nREVISION    CHANGE-CAUSE\n1       kubectl scale deployment/vote --replicas=5\n3       \nnone\n\n6       \nnone\n\n7       \nnone\n\n\nroot@kube-01:~# kubectl rollout history deployment/vote --revision=7\ndeployments \nvote\n with revision #7\nPod Template:\n  Labels:   app=vote\n    env=dev\n    pod-template-hash=4086029260\n    role=ui\n    stack=voting\n    tier=front\n  Containers:\n   vote:\n    Image:  schoolofdevops/vote:movi\n    Port:   80/TCP\n    Environment:    \nnone\n\n    Mounts: \nnone\n\n  Volumes:  \nnone\n\n\n\n\n\nTo undo rollout,\n\n\nkubectl rollout undo deployment/vote\n\n\n\n\nor\n\n\nkubectl rollout undo deployment/vote --to-revision=1\nkubectl get rs\nkubectl describe deployment vote", 
            "title": "Rollouts and Rollbacks"
        }, 
        {
            "location": "/8_rollouts_and_rollbacks/#rolling-updates-with-deployments", 
            "text": "Lets create the update/deployment strategy as follows  revisionHistoryLimit: 4\nstrategy:\n  type: RollingUpdate\n  rollingUpdate:\n    maxUnavailable: 1\n    maxSurge: 2\nminReadySeconds: 20  Here,  strategy.type  : rolling updates which deploys pods in batches. Batch size is determined by following factors\n  * maxUnavailable\n  * maxSurge  minReadySeconds  : Time taken by the application to come up and be operational.  The above specs need to be added to the deployment configs as follows,  File: vote-deploy.yaml  apiVersion: extensions/v1beta1\nkind: Deployment\nmetadata:\n  name: vote\nspec:\n  replicas: 8\n  revisionHistoryLimit: 4\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 1\n      maxSurge: 2\n  minReadySeconds: 20\n  template:\n    metadata:\n      labels:\n        app: vote\n        role: ui\n    spec:\n      containers:\n      - image: schoolofdevops/vote\n        name: vote\n        ports:\n        - containerPort: 80\n          protocol: TCP  Update the version of the image in vote_deploy.yaml  File: vote-deploy.yaml  ...\n    app: vote\n    spec:\n      containers:\n      - image: schoolofdevops/vote:movies  Apply Changes and monitor the rollout  kubectl apply -f vote-deploy.yaml\nkubectl rollout status deployment/vote", 
            "title": "Rolling updates with deployments"
        }, 
        {
            "location": "/8_rollouts_and_rollbacks/#rolling-back-a-failed-update", 
            "text": "Lets update the image to a tag which is non existent. We intentionally introduce this intentional error to fail fail the deployment.  File: vote-deploy.yaml  ...\n    app: vote\n    spec:\n      containers:\n      - image: schoolofdevops/vote:movi  Do a new rollout and monitor  kubectl apply -f vote-deploy.yaml\nkubectl rollout status deployment/vote  Also watch the pod status which might look like  vote-3040199436-sdq17   1/1       Running            0          9m\nvote-4086029260-0vjjb   0/1       ErrImagePull       0          16s\nvote-4086029260-zvgmd   0/1       ImagePullBackOff   0          15s\nvote-rc-fsdsd               1/1       Running            0          27m\nvote-rc-mcxs5               1/1       Running            0  To get the revision history and details    kubectl rollout history deployment/vote\nkubectl rollout history deployment/vote --revision=x\n[replace x with the latest revision]  [Sample Output]  root@kube-01:~# kubectl rollout history deployment/vote\ndeployments  vote \nREVISION    CHANGE-CAUSE\n1       kubectl scale deployment/vote --replicas=5\n3        none \n6        none \n7        none \n\nroot@kube-01:~# kubectl rollout history deployment/vote --revision=7\ndeployments  vote  with revision #7\nPod Template:\n  Labels:   app=vote\n    env=dev\n    pod-template-hash=4086029260\n    role=ui\n    stack=voting\n    tier=front\n  Containers:\n   vote:\n    Image:  schoolofdevops/vote:movi\n    Port:   80/TCP\n    Environment:     none \n    Mounts:  none \n  Volumes:   none   To undo rollout,  kubectl rollout undo deployment/vote  or  kubectl rollout undo deployment/vote --to-revision=1\nkubectl get rs\nkubectl describe deployment vote", 
            "title": "Rolling Back a Failed Update"
        }
    ]
}